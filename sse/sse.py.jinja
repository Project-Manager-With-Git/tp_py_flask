import json
import flask
from flask import Flask
from collections import OrderedDict
from typing import Optional, Union, Dict, Any, TypedDict, Callable, Generator, OrderedDict as OrderedDictT


class MessageDict(TypedDict, total=False):
    data: Union[str, Dict[str, Any]]
    type: str
    id: Union[str, int]
    retry: int


class Message:
    """
    Data that is published as a server-sent event.
    """

    def __init__(self, data: Union[str, Dict[str, Any]], _type: Optional[str] = None, id: Optional[Union[str, int]] = None, retry: Optional[int] = None) -> None:
        """
        Create a server-sent event.
        :param data: The event data. If it is not a string, it will be
            serialized to JSON using the Flask application's
            :class:`~flask.json.JSONEncoder`.
        :param type: An optional event type.
        :param id: An optional event ID.
        :param retry: An optional integer, to specify the reconnect time for
            disconnected clients of this stream.
        """
        self.data = data
        self.type = _type
        self.id = id
        self.retry = retry

    def to_dict(self) -> MessageDict:
        """
        Serialize this object to a minimal dictionary, for storing in Redis.
        """
        # data is required, all others are optional
        d: MessageDict = {"data": self.data}
        if self.type:
            d["type"] = self.type
        if self.id:
            d["id"] = self.id
        if self.retry:
            d["retry"] = self.retry
        return d

    def __str__(self) -> str:
        """
        Serialize this object to a string, according to the `server-sent events
        specification <https://www.w3.org/TR/eventsource/>`_.
        """
        if isinstance(self.data, str):
            data = self.data
        else:
            data = json.dumps(self.data)
        lines = ["data:{value}".format(value=line) for line in data.splitlines()]
        if self.type:
            lines.insert(0, "event:{value}".format(value=self.type))
        if self.id:
            lines.append("id:{value}".format(value=self.id))
        if self.retry:
            lines.append("retry:{value}".format(value=self.retry))
        return "\n".join(lines) + "\n\n"

    def __repr__(self) -> str:
        kwargs: OrderedDictT[str, Any] = OrderedDict()
        if self.type:
            kwargs["type"] = self.type
        if self.id:
            kwargs["id"] = self.id
        if self.retry:
            kwargs["retry"] = self.retry
        kwargs_repr = "".join(
            ", {key}={value!r}".format(key=key, value=value)
            for key, value in kwargs.items()
        )
        return "{classname}({data!r}{kwargs})".format(
            classname=self.__class__.__name__,
            data=self.data,
            kwargs=kwargs_repr,
        )

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Message):
            return all([
                isinstance(other, self.__class__),
                self.data == other.data,
                self.id == other.id,
                self.retry == other.retry
            ])
        else:
            raise NotImplemented


class SSE:
    def __init__(self, app: Flask) -> None:
        self.app = app

    def add_url_rule(self, url: str, *, stream_func: Callable[..., Generator[str, None, None]]) -> None:
        stream_func_name = stream_func.__name__
        self.app.endpoint(stream_func_name)(lambda *args, **kw: flask.Response(stream_func(*args, **kw), mimetype='text/event-stream'))
        self.app.add_url_rule(url, endpoint=stream_func_name, methods=['GET'])
